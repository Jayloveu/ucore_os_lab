### OS Lab 8 Report

#### 计55  陈齐斌  2015011403

### 练习 0：填写已有实验

- 与 lab7 代码合并后，还需要增加一下部分：
- alloc_proc 中对 filesp 的初始化
- do_fork 中，copy_files 的执行以及相应异常的处理

### 练习 1: 完成读文件操作的实现（需要编码）

#### 1.1 首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。

- 打开文件与读写文件，都是通过系统调用，然后通过层层嵌套，由文件系统完成操作后，将结果层层返回。
- 参考 ucore lab docs 中的文件读写操作的分析，可以了解到读文件时通过调用 sys_read 到 VFS 层到 file_read 再到 vop_read，然后就到了 SFS 层的 sfs_read。需要填写的部分是 sfs_io_nolock.
- 设计与实现流程
  - 根据提示，实现分三种情况
  - 偏置量起始位置与 block 没有对齐，此时先算出需要读的大小 `(nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);`，然后需要调用 sfs_buf_op。 sfs_buf_op 以及 sfs_block_op 是为了统一 read 和 write 的接口，两者都可以对数据块进行读写，而前者主要用于没有对齐的情况，后者主要用于整个块的读写。
  - 读写整个 block 的情况，可以使用一个 while 语句循环读取直到没有完整的 block 可以读
  - 结束位置没有与 block 对齐的情况，与第一种情况类似，甚至更加简单，从上一个读完整的位置再读到 endpos 即可
- 对 `sfs_bmap_load_nolock` 等函数的调用方式以及异常情况的处理参考了答案。

#### 1.2 请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案

- 首先设计 PIPE 机制使用的接口，通过系统调用的方式实现创建管道，可以返回两个打开的文件描述符指针，作为 pipe 的 in 和 out 端，相应的应该设置为 write only 以及 read only。这样一个进程在往 in 端写的时候，另一个进程可以在 out 文件读到数据。
- 具体的实现可以这样尝试：
  - 与普通的打开的文件不同，这两个特殊的文件接口首先初始内容为空，其次应能共享同一片区域，因此可以在管道新建时为其建立一片区域作为缓冲区，并记录有效数据的起始位置和长度。
  - 在 pipe 的 write 时可以调用普通文件的写操作，而写的位置则由缓冲区中有效数据的起始位置以及长度确定，read 同理
  - 需要注意的是，由于两个进程分别的 write 和 read 都需要缓冲区的更新，因此应该保证他们互斥访问，可以用信号量来实现。

### 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）

#### 2.1 改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。

- 设计与实现思路
  - 第一步可以复制 lab7 的 load_icode 代码
  - 基于原函数，需要将 exec 从内存中 binary 处用户程序，改为调用 `load_icode_read` 接口，用文件 fd 读取文件形式的用户程序，而读出之后解析 ELF 的部分不受影响。
  - 之后此次实验还需要增加再用户栈顶放置命令行参数，这部分实现参考了答案
    - 由于用户代码的参数需要被用户程序使用，因此这里需要将内核态中参数的值（字符串）拷贝至栈上，并且按同样的顺序（逆序）再把指向这些参数的指针放到栈上，最后栈顶放上参数个数
    - 可以通过答案中 stacktop 位置的计算看出需要给用户栈上构造的结构，而事实上可以通过观察 `umain.c` 程序中对参数的使用发现这一点。因此我们先计算所有参数字符的总长度，指向这些位置的字符串指针所占用的空间、以及存放参数个数的 argc 的一个 int 的大小。然后进一步细化，依次将 kargv（放在内核内存空间中的参数拷贝至栈上）。
    - 需要注意的是，此时用户栈真正的栈顶已经不是常量 USTACKTOP，因此在下面的 trapframe 中 esp 需要改成放置参数后新的栈顶。

#### 2.2 请在实验报告中给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案，鼓励给出详细设计方案

- 硬链接机制
  - 创建一个硬链接时，只需提供被链接的文件的 inode，并新建一项并且把其 inode 索引号设置为该 inode 号，同时对该 inode 增加引用计数
  - 在删除文件的时候，由于可能有硬链接的存在，因此只把引用计数 -1，如果为 0 才进行真的删除，引用计数这一部分在 ucore 中已经实现。
- 软链接机制
  - 软链接本身也是一个文件，对应不同与被链接文件的 inode，创建软链接时，将文件内容设置为目标文件路径的字符串，删除软链接跟删除文件没有区别
  - 在打开文件等操作中需要对软链接进行特殊处理，以打开被链接的文件。可以在 lookup 等函数中实现，并可以设置是否 follow 指向其他目录的软链接等参数

### 3 总结

#### 3.1 与参考答案区别：

- `sfs_io_nolock` 函数的第一种情况的实现参考了答案的对 `sfs_bmap_load_nolock` 的调用；并根据答案完善了异常的处理等
- `load_icode` 中在用户栈上放置命令行参数参考了答案

#### 3.2 重要与缺失知识点

- 重要知识点
  - 虚拟文件系统，简单文件系统
  - 文件描述符、目录
  - inode
  - 管道
- 缺失知识点
  - 磁盘调度算法
  - 磁盘缓存
  - 冗余磁盘阵列
